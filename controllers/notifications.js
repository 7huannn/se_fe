// controllers/notifications.js - Updated with team notifications
import { initNotificationsView, renderNotificationItem } from "../views/notificationsView.js";

/**
 * Controller ƒë·ªÉ kh·ªüi t·∫°o notifications:
 * - B·∫Øt c√°c s·ª± ki·ªán li√™n quan ƒë·∫øn notifications (events v√† teams)
 * - X·ª≠ l√Ω th√¥ng b√°o event, team, c·∫≠p nh·∫≠t badge, toggle dropdown
 */
export function initNotificationsController() {
  // Kh·ªüi t·∫°o view, l·∫•y c√°c elements v√† API
  const notificationsAPI = initNotificationsView();
  
  // FIX: Ki·ªÉm tra API c√≥ t·ªìn t·∫°i kh√¥ng
  if (!notificationsAPI || !notificationsAPI.notificationBtn) {
    console.warn("Notifications view initialization failed");
    return {};
  }
  
  const { 
    notificationBtn, 
    notificationBadge,
    notificationDropdown,
    notificationList,
    emptyNotification,
    toggleDropdown, 
    updateBadge,
    toaster
  } = notificationsAPI;
  
  // M·∫£ng l∆∞u tr·ªØ th√¥ng b√°o
  let notifications = loadNotifications();
  let unreadCount = countUnreadNotifications(notifications);
  
  // C·∫≠p nh·∫≠t badge ban ƒë·∫ßu
  updateBadge(unreadCount);
  
  // Toggle dropdown khi click v√†o button
  notificationBtn.addEventListener("click", (e) => {
    e.stopPropagation();
    toggleDropdown();
    renderNotifications();
    
    // ƒê√°nh d·∫•u t·∫•t c·∫£ l√† ƒë√£ ƒë·ªçc khi m·ªü dropdown
    if (unreadCount > 0) {
      markAllAsRead();
    }
  });
  
  // ƒê√≥ng dropdown khi click ra ngo√†i
  document.addEventListener("click", (e) => {
    if (notificationDropdown && notificationDropdown.classList.contains('show')) {
      if (!notificationDropdown.contains(e.target) && e.target !== notificationBtn) {
        toggleDropdown();
      }
    }
  });
  
  // ==============================================
  // EVENT NOTIFICATIONS (Existing)
  // ==============================================
  
  // L·∫Øng nghe s·ª± ki·ªán t·∫°o event
  document.addEventListener("event-create", (e) => {
    const eventData = e.detail.event || e.detail;
    addNotification({
      type: 'event-create',
      category: 'event',
      message: `Event "${eventData.title}" created`,
      timestamp: Date.now(),
      read: false,
      eventId: eventData.id,
      icon: '‚ûï'
    });
    
    if (toaster && toaster.success) {
      toaster.success("Event has been created");
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán s·ª≠a event
  document.addEventListener("event-edit", (e) => {
    const eventData = e.detail.event || e.detail;
    addNotification({
      type: 'event-edit',
      category: 'event',
      message: `Event "${eventData.title}" updated`,
      timestamp: Date.now(),
      read: false,
      eventId: eventData.id,
      icon: '‚úèÔ∏è'
    });
    
    if (toaster && toaster.success) {
      toaster.success("Event has been edited");
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán xo√° event
  document.addEventListener("event-delete", (e) => {
    const eventData = e.detail.event || e.detail;
    addNotification({
      type: 'event-delete',
      category: 'event',
      message: `Event "${eventData.title || 'Event'}" deleted`,
      timestamp: Date.now(),
      read: false,
      icon: 'üóëÔ∏è'
    });
    
    if (toaster && toaster.success) {
      toaster.success("Event has been deleted");
    }
  });
  
  // ==============================================
  // TEAM NOTIFICATIONS (New)
  // ==============================================
  
  // L·∫Øng nghe s·ª± ki·ªán t·∫°o team
  document.addEventListener("team-create", (e) => {
    const teamData = e.detail.team;
    const currentUser = getCurrentUser();
    
    addNotification({
      type: 'team-create',
      category: 'team',
      message: `Team "${teamData.name}" created successfully`,
      timestamp: Date.now(),
      read: false,
      teamId: teamData.id,
      icon: 'üë•'
    });
    
    if (toaster && toaster.success) {
      toaster.success("Team created successfully");
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán th√™m th√†nh vi√™n v√†o team
  document.addEventListener("team-member-add", (e) => {
    const { teamId, member } = e.detail;
    const team = getTeamById(teamId);
    const currentUser = getCurrentUser();
    
    if (team) {
      // Th√¥ng b√°o cho ng∆∞·ªùi th√™m
      addNotification({
        type: 'team-member-add',
        category: 'team',
        message: `${member.name || member.email} added to team "${team.name}"`,
        timestamp: Date.now(),
        read: false,
        teamId: teamId,
        memberId: member.id,
        icon: '‚ûïüë§'
      });
      
      // N·∫øu l√† th√™m ng∆∞·ªùi kh√°c (kh√¥ng ph·∫£i b·∫£n th√¢n)
      if (member.email.toLowerCase() !== currentUser.email.toLowerCase()) {
        // C√≥ th·ªÉ th√™m logic ƒë·ªÉ g·ª≠i th√¥ng b√°o cho member ƒë∆∞·ª£c th√™m v√†o
        // (trong th·ª±c t·∫ø c·∫ßn API backend ƒë·ªÉ g·ª≠i th√¥ng b√°o qua email/push notification)
        console.log(`Should notify ${member.email} about being added to team ${team.name}`);
      }
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán x√≥a th√†nh vi√™n kh·ªèi team
  document.addEventListener("team-member-remove", (e) => {
    const { teamId, memberId } = e.detail;
    const team = getTeamById(teamId);
    
    if (team) {
      // T√¨m th√¥ng tin member ƒë√£ b·ªã x√≥a
      const removedMember = team.members?.find(m => m.id === memberId);
      const memberName = removedMember ? (removedMember.name || removedMember.email) : 'Member';
      
      addNotification({
        type: 'team-member-remove',
        category: 'team',
        message: `${memberName} removed from team "${team.name}"`,
        timestamp: Date.now(),
        read: false,
        teamId: teamId,
        icon: '‚ûñüë§'
      });
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán thay ƒë·ªïi role th√†nh vi√™n
  document.addEventListener("team-member-role-change", (e) => {
    const { teamId, memberId, role } = e.detail;
    const team = getTeamById(teamId);
    
    if (team) {
      const member = team.members?.find(m => m.id === memberId);
      const memberName = member ? (member.name || member.email) : 'Member';
      
      const roleText = role === 'leader' ? 'promoted to Leader' : 'changed to Member';
      const icon = role === 'leader' ? 'üëë' : 'üë§';
      
      addNotification({
        type: 'team-member-role-change',
        category: 'team',
        message: `${memberName} ${roleText} in team "${team.name}"`,
        timestamp: Date.now(),
        read: false,
        teamId: teamId,
        memberId: memberId,
        newRole: role,
        icon: icon
      });
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán ch·ªânh s·ª≠a team
  document.addEventListener("team-edit", (e) => {
    const { teamId, updateData } = e.detail;
    const team = getTeamById(teamId);
    
    if (team) {
      addNotification({
        type: 'team-edit',
        category: 'team',
        message: `Team "${team.name}" details updated`,
        timestamp: Date.now(),
        read: false,
        teamId: teamId,
        icon: '‚úèÔ∏è'
      });
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán x√≥a team
  document.addEventListener("team-delete", (e) => {
    const { teamId } = e.detail;
    
    // L·∫•y t√™n team tr∆∞·ªõc khi x√≥a (n·∫øu c√≤n trong localStorage)
    const teams = JSON.parse(localStorage.getItem('schedigo_teams') || '[]');
    const team = teams.find(t => t.id === teamId);
    const teamName = team ? team.name : 'Team';
    
    addNotification({
      type: 'team-delete',
      category: 'team',
      message: `Team "${teamName}" has been deleted`,
      timestamp: Date.now(),
      read: false,
      icon: 'üóëÔ∏èüë•'
    });
    
    if (toaster && toaster.success) {
      toaster.success("Team deleted successfully");
    }
  });
  
  // L·∫Øng nghe s·ª± ki·ªán thay ƒë·ªïi privacy team
  document.addEventListener("team-privacy-update", (e) => {
    const { teamId, privacy } = e.detail;
    const team = getTeamById(teamId);
    
    if (team) {
      const privacyText = privacy === 'private' ? 'Private' : 'Public';
      const icon = privacy === 'private' ? 'üîí' : 'üåê';
      
      addNotification({
        type: 'team-privacy-update',
        category: 'team',
        message: `Team "${team.name}" changed to ${privacyText}`,
        timestamp: Date.now(),
        read: false,
        teamId: teamId,
        newPrivacy: privacy,
        icon: icon
      });
    }
  });
  
  /**
   * Th√™m notification m·ªõi
   * @param {Object} notification - Th√¥ng tin notification
   */
  function addNotification(notification) {
    // Th√™m v√†o ƒë·∫ßu m·∫£ng
    notifications.unshift(notification);
    
    // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng th√¥ng b√°o (gi·ªØ 50 th√¥ng b√°o g·∫ßn nh·∫•t)
    if (notifications.length > 50) {
      notifications = notifications.slice(0, 50);
    }
    
    // L∆∞u v√†o localStorage
    saveNotifications(notifications);
    
    // C·∫≠p nh·∫≠t s·ªë l∆∞·ª£ng ch∆∞a ƒë·ªçc
    unreadCount++;
    updateBadge(unreadCount);
  }
  
  /**
   * ƒê√°nh d·∫•u t·∫•t c·∫£ th√¥ng b√°o l√† ƒë√£ ƒë·ªçc
   */
  function markAllAsRead() {
    notifications.forEach(notification => {
      notification.read = true;
    });
    
    // L∆∞u v√†o localStorage
    saveNotifications(notifications);
    
    // C·∫≠p nh·∫≠t badge
    unreadCount = 0;
    updateBadge(0);
  }
  
  /**
   * Render danh s√°ch th√¥ng b√°o
   */
  function renderNotifications() {
    if (!notificationList || !emptyNotification) return;
    
    // Clear current list
    notificationList.innerHTML = '';
    
    if (notifications.length === 0) {
      // Show empty message
      emptyNotification.classList.remove('hidden');
    } else {
      // Hide empty message
      emptyNotification.classList.add('hidden');
      
      // Group notifications by category
      const groupedNotifications = groupNotificationsByCategory(notifications);
      
      // Render each group
      Object.entries(groupedNotifications).forEach(([category, categoryNotifications]) => {
        // Add category header if there are multiple categories
        if (Object.keys(groupedNotifications).length > 1) {
          const categoryHeader = document.createElement('div');
          categoryHeader.className = 'notification-category-header';
          categoryHeader.textContent = getCategoryDisplayName(category);
          notificationList.appendChild(categoryHeader);
        }
        
        // Render notifications in this category
        categoryNotifications.forEach(notification => {
          const notificationItem = renderNotificationItem(notification);
          notificationList.appendChild(notificationItem);
        });
      });
    }
  }
  
  /**
   * Group notifications by category
   * @param {Array} notifications - Array of notifications
   * @returns {Object} Grouped notifications
   */
  function groupNotificationsByCategory(notifications) {
    return notifications.reduce((groups, notification) => {
      const category = notification.category || 'general';
      if (!groups[category]) {
        groups[category] = [];
      }
      groups[category].push(notification);
      return groups;
    }, {});
  }
  
  /**
   * Get display name for category
   * @param {string} category - Category key
   * @returns {string} Display name
   */
  function getCategoryDisplayName(category) {
    const categoryNames = {
      'event': 'üìÖ Events',
      'team': 'üë• Teams',
      'general': 'üîî General'
    };
    
    return categoryNames[category] || 'üîî General';
  }
  
  /**
   * L·∫•y th√¥ng b√°o t·ª´ localStorage
   * @returns {Array} Danh s√°ch th√¥ng b√°o
   */
  function loadNotifications() {
    try {
      const stored = localStorage.getItem('schedigo_notifications');
      return stored ? JSON.parse(stored) : [];
    } catch (error) {
      console.error('Error loading notifications', error);
      return [];
    }
  }
  
  /**
   * L∆∞u th√¥ng b√°o v√†o localStorage
   * @param {Array} notifications - Danh s√°ch th√¥ng b√°o
   */
  function saveNotifications(notifications) {
    try {
      localStorage.setItem('schedigo_notifications', JSON.stringify(notifications));
    } catch (error) {
      console.error('Error saving notifications', error);
    }
  }
  
  /**
   * ƒê·∫øm s·ªë th√¥ng b√°o ch∆∞a ƒë·ªçc
   * @param {Array} notifications - Danh s√°ch th√¥ng b√°o
   * @returns {number} S·ªë th√¥ng b√°o ch∆∞a ƒë·ªçc
   */
  function countUnreadNotifications(notifications) {
    return notifications.filter(notification => !notification.read).length;
  }
  
  /**
   * Get team by ID
   * @param {number} teamId - Team ID
   * @returns {Object|null} Team object or null
   */
  function getTeamById(teamId) {
    try {
      const teams = JSON.parse(localStorage.getItem('schedigo_teams') || '[]');
      return teams.find(team => team.id === teamId) || null;
    } catch (error) {
      console.error('Error getting team by ID:', error);
      return null;
    }
  }
  
  /**
   * Get current user information
   * @returns {Object} Current user info
   */
  function getCurrentUser() {
    return {
      email: localStorage.getItem('email') || '',
      name: localStorage.getItem('username') || 'User'
    };
  }
  
  // Public API
  return {
    toaster,
    addNotification,
    markAllAsRead,
    getNotifications: () => notifications,
    clearNotifications: () => {
      notifications = [];
      saveNotifications([]);
      unreadCount = 0;
      updateBadge(0);
      renderNotifications();
    }
  };
}