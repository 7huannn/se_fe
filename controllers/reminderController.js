// controllers/reminderController.js - Controller cho reminder management
import { reminderService } from '../services/reminderService.js';
import { reminderView } from '../views/reminderView.js';

/**
 * Controller cho reminder management
 */
export class ReminderController {
  constructor() {
    this.currentReminders = new Map(); // Map ƒë·ªÉ l∆∞u reminders theo eventId
  }

  /**
   * Kh·ªüi t·∫°o reminder controller
   */
  init() {
    // Kh·ªüi t·∫°o view
    reminderView.init();

    // L·∫Øng nghe c√°c s·ª± ki·ªán t·ª´ view
    this.bindEvents();

    // Th√™m reminder button v√†o event details dialog
    this.addReminderButtonToEventDetails();
  }

  /**
   * Bind c√°c s·ª± ki·ªán
   */
  bindEvents() {
    // L·∫Øng nghe s·ª± ki·ªán t·∫°o reminder
    document.addEventListener('reminder-create', (e) => {
      this.handleCreateReminder(e.detail);
    });

    // L·∫Øng nghe s·ª± ki·ªán c·∫≠p nh·∫≠t reminder
    document.addEventListener('reminder-update', (e) => {
      this.handleUpdateReminder(e.detail);
    });

    // L·∫Øng nghe s·ª± ki·ªán x√≥a reminder
    document.addEventListener('reminder-delete', (e) => {
      this.handleDeleteReminder(e.detail);
    });

    // L·∫Øng nghe s·ª± ki·ªán m·ªü reminder modal t·ª´ event details
    document.addEventListener('reminder-open', (e) => {
      this.handleOpenReminder(e.detail);
    });
  }

  /**
   * Th√™m n√∫t reminder v√†o event details dialog
   */
  addReminderButtonToEventDetails() {
    // Observer ƒë·ªÉ theo d√µi khi event details dialog ƒë∆∞·ª£c t·∫°o
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const eventDetailsDialog = node.querySelector('[data-dialog="event-details"]') || 
                                     (node.matches && node.matches('[data-dialog="event-details"]') ? node : null);
            
            if (eventDetailsDialog) {
              this.addReminderButtonToDialog(eventDetailsDialog);
            }
          }
        });
      });
    });

    observer.observe(document.body, {
      childList: true,
      subtree: true
    });

    // Ki·ªÉm tra dialog ƒë√£ t·ªìn t·∫°i
    const existingDialog = document.querySelector('[data-dialog="event-details"]');
    if (existingDialog) {
      this.addReminderButtonToDialog(existingDialog);
    }
  }

  /**
   * Th√™m n√∫t reminder v√†o dialog c·ª• th·ªÉ
   * @param {HTMLElement} dialog - Event details dialog
   */
  addReminderButtonToDialog(dialog) {
    // Ki·ªÉm tra xem ƒë√£ c√≥ n√∫t reminder ch∆∞a
    if (dialog.querySelector('.reminder-btn')) return;

    // T√¨m container cho c√°c n√∫t action
    let actionContainer = dialog.querySelector('.event-details-actions');
    
    if (!actionContainer) {
      // T·∫°o container n·∫øu ch∆∞a c√≥
      actionContainer = document.createElement('div');
      actionContainer.className = 'event-details-actions';
      
      // T√¨m v·ªã tr√≠ ph√π h·ª£p ƒë·ªÉ th√™m container
      const editBtn = dialog.querySelector('[data-event-details-edit-button]');
      const deleteBtn = dialog.querySelector('[data-event-details-delete-button]');
      
      if (editBtn && deleteBtn) {
        // T·∫°o container ch·ª©a t·∫•t c·∫£ c√°c n√∫t
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'event-details-buttons';
        
        // Move existing buttons to new container
        const editBtnParent = editBtn.parentNode;
        buttonsContainer.appendChild(editBtn);
        buttonsContainer.appendChild(deleteBtn);
        
        // Add action container
        buttonsContainer.appendChild(actionContainer);
        editBtnParent.appendChild(buttonsContainer);
      } else {
        // Fallback: th√™m v√†o cu·ªëi dialog content
        const dialogContent = dialog.querySelector('.modal-body') || dialog.querySelector('.dialog-content');
        if (dialogContent) {
          dialogContent.appendChild(actionContainer);
        }
      }
    }

    // T·∫°o n√∫t reminder
    const reminderBtn = document.createElement('button');
    reminderBtn.className = 'btn btn-outline-primary reminder-btn';
    reminderBtn.type = 'button';
    reminderBtn.innerHTML = 'üîî Reminder';
    reminderBtn.title = 'Set reminder for this event';

    // Th√™m s·ª± ki·ªán click
    reminderBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      this.handleReminderButtonClick(dialog);
    });

    actionContainer.appendChild(reminderBtn);

    // Th√™m styles n·∫øu c·∫ßn
    this.addReminderButtonStyles();
  }

  /**
   * X·ª≠ l√Ω click n√∫t reminder trong event details
   * @param {HTMLElement} dialog - Event details dialog
   */
  handleReminderButtonClick(dialog) {
    // L·∫•y th√¥ng tin event t·ª´ dialog
    const eventTitle = dialog.querySelector('[data-event-details-title]')?.textContent;
    const eventDate = dialog.querySelector('[data-event-details-date]')?.textContent;
    const eventStartTime = dialog.querySelector('[data-event-details-start-time]')?.textContent;
    
    if (!eventTitle) {
      console.error('Cannot get event information from dialog');
      return;
    }

    // T·∫°o event data t·∫°m th·ªùi (c·∫ßn ƒë∆∞·ª£c c·∫£i thi·ªán ƒë·ªÉ l·∫•y ƒë·∫ßy ƒë·ªß th√¥ng tin)
    const eventData = {
      id: this.getEventIdFromDialog(dialog),
      title: eventTitle,
      date: eventDate,
      start_time: this.parseEventDateTime(eventDate, eventStartTime)
    };

    // Ki·ªÉm tra xem event ƒë√£ c√≥ reminder ch∆∞a
    this.checkExistingReminder(eventData);
  }

  /**
   * L·∫•y event ID t·ª´ dialog (c·∫ßn implement d·ª±a tr√™n c·∫•u tr√∫c dialog)
   * @param {HTMLElement} dialog - Event details dialog
   */
  getEventIdFromDialog(dialog) {
    // C·∫ßn implement c√°ch l·∫•y event ID t·ª´ dialog
    // C√≥ th·ªÉ t·ª´ data attribute ho·∫∑c t·ª´ context kh√°c
    return dialog.dataset.eventId || null;
  }

  /**
   * Parse th·ªùi gian event t·ª´ text
   * @param {string} dateText - Text ng√†y
   * @param {string} timeText - Text gi·ªù
   */
  parseEventDateTime(dateText, timeText) {
    // Implementation ƒë·ªÉ parse th·ªùi gian event
    // Tr·∫£ v·ªÅ ISO string ho·∫∑c Date object
    try {
      const date = new Date(`${dateText} ${timeText}`);
      return date.toISOString();
    } catch (error) {
      console.error('Error parsing event date time:', error);
      return new Date().toISOString();
    }
  }

  /**
   * Ki·ªÉm tra reminder ƒë√£ t·ªìn t·∫°i cho event
   * @param {Object} eventData - Th√¥ng tin event
   */
  async checkExistingReminder(eventData) {
    if (!eventData.id) {
      // N·∫øu kh√¥ng c√≥ ID, m·ªü modal t·∫°o m·ªõi
      reminderView.openCreateModal(eventData);
      return;
    }

    // Ki·ªÉm tra cache local tr∆∞·ªõc
    const cachedReminder = this.currentReminders.get(eventData.id);
    if (cachedReminder) {
      reminderView.openEditModal(eventData, cachedReminder);
      return;
    }

    // TODO: G·ªçi API ƒë·ªÉ l·∫•y reminders c·ªßa event
    // Hi·ªán t·∫°i m·ªü modal t·∫°o m·ªõi
    reminderView.openCreateModal(eventData);
  }

  /**
   * X·ª≠ l√Ω t·∫°o reminder m·ªõi
   * @param {Object} data - D·ªØ li·ªáu t·ª´ event
   */
  async handleCreateReminder(data) {
    const { eventId, reminderData } = data;

    try {
      const result = await reminderService.createReminder(eventId, reminderData);

      if (result.success) {
        // L∆∞u v√†o cache
        this.currentReminders.set(eventId, result.reminder);
        
        // ƒê√≥ng modal
        reminderView.closeModal();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        this.showToast('Reminder created successfully', 'success');
        
        // Dispatch event ƒë·ªÉ c·∫≠p nh·∫≠t UI kh√°c n·∫øu c·∫ßn
        document.dispatchEvent(new CustomEvent('reminder-created', {
          detail: { eventId, reminder: result.reminder },
          bubbles: true
        }));
      } else {
        this.showToast(result.message || 'Failed to create reminder', 'error');
      }
    } catch (error) {
      console.error('Error creating reminder:', error);
      this.showToast('An error occurred while creating reminder', 'error');
    }
  }

  /**
   * X·ª≠ l√Ω c·∫≠p nh·∫≠t reminder
   * @param {Object} data - D·ªØ li·ªáu t·ª´ event
   */
  async handleUpdateReminder(data) {
    const { eventId, reminderId, reminderData } = data;

    try {
      const result = await reminderService.updateReminder(eventId, reminderId, reminderData);

      if (result.success) {
        // C·∫≠p nh·∫≠t cache
        this.currentReminders.set(eventId, result.reminder);
        
        // ƒê√≥ng modal
        reminderView.closeModal();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        this.showToast('Reminder updated successfully', 'success');
        
        // Dispatch event ƒë·ªÉ c·∫≠p nh·∫≠t UI kh√°c n·∫øu c·∫ßn
        document.dispatchEvent(new CustomEvent('reminder-updated', {
          detail: { eventId, reminderId, reminder: result.reminder },
          bubbles: true
        }));
      } else {
        this.showToast(result.message || 'Failed to update reminder', 'error');
      }
    } catch (error) {
      console.error('Error updating reminder:', error);
      this.showToast('An error occurred while updating reminder', 'error');
    }
  }

  /**
   * X·ª≠ l√Ω x√≥a reminder
   * @param {Object} data - D·ªØ li·ªáu t·ª´ event
   */
  async handleDeleteReminder(data) {
    const { eventId, reminderId } = data;

    try {
      const result = await reminderService.deleteReminder(eventId, reminderId);

      if (result.success) {
        // X√≥a kh·ªèi cache
        this.currentReminders.delete(eventId);
        
        // ƒê√≥ng modal
        reminderView.closeModal();
        
        // Hi·ªÉn th·ªã th√¥ng b√°o th√†nh c√¥ng
        this.showToast('Reminder deleted successfully', 'success');
        
        // Dispatch event ƒë·ªÉ c·∫≠p nh·∫≠t UI kh√°c n·∫øu c·∫ßn
        document.dispatchEvent(new CustomEvent('reminder-deleted', {
          detail: { eventId, reminderId },
          bubbles: true
        }));
      } else {
        this.showToast(result.message || 'Failed to delete reminder', 'error');
      }
    } catch (error) {
      console.error('Error deleting reminder:', error);
      this.showToast('An error occurred while deleting reminder', 'error');
    }
  }

  /**
   * X·ª≠ l√Ω m·ªü reminder t·ª´ external request
   * @param {Object} data - D·ªØ li·ªáu event
   */
  handleOpenReminder(data) {
    const { eventData } = data;
    this.checkExistingReminder(eventData);
  }

  /**
   * L·∫•y reminder cho m·ªôt event
   * @param {number} eventId - ID c·ªßa event
   * @returns {Object|null} Reminder data ho·∫∑c null
   */
  async getReminderForEvent(eventId) {
    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cachedReminder = this.currentReminders.get(eventId);
    if (cachedReminder) {
      return cachedReminder;
    }

    // TODO: Implement API call ƒë·ªÉ l·∫•y reminders c·ªßa event
    // Hi·ªán t·∫°i backend kh√¥ng c√≥ endpoint ƒë·ªÉ list reminders theo event
    return null;
  }

  /**
   * Load t·∫•t c·∫£ reminders cho c√°c events
   * @param {Array} eventIds - Danh s√°ch event IDs
   */
  async loadRemindersForEvents(eventIds) {
    // TODO: Implement batch loading reminders
    // Hi·ªán t·∫°i backend kh√¥ng h·ªó tr·ª£ batch loading
    console.log('Loading reminders for events:', eventIds);
  }

  /**
   * Hi·ªÉn th·ªã toast notification
   * @param {string} message - Th√¥ng b√°o
   * @param {string} type - Lo·∫°i th√¥ng b√°o (success, error, warning)
   */
  showToast(message, type = 'success') {
    // T√¨m ho·∫∑c t·∫°o toast container
    let toastContainer = document.querySelector('.toast-container');
    if (!toastContainer) {
      toastContainer = document.createElement('div');
      toastContainer.className = 'toast-container';
      document.body.appendChild(toastContainer);
    }

    // T·∫°o toast element
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;

    // Th√™m v√†o container
    toastContainer.appendChild(toast);

    // T·ª± ƒë·ªông x√≥a sau 3 gi√¢y
    setTimeout(() => {
      toast.classList.add('fade-out');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }, 3000);
  }

  /**
   * Th√™m styles cho n√∫t reminder
   */
  addReminderButtonStyles() {
    if (document.getElementById('reminder-button-styles')) return;

    const styleEl = document.createElement('style');
    styleEl.id = 'reminder-button-styles';
    styleEl.textContent = `
      .event-details-actions {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid #eee;
      }

      .event-details-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .reminder-btn {
        background: none;
        border: 1px solid #007bff;
        color: #007bff;
        padding: 0.375rem 0.75rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.2s;
      }

      .reminder-btn:hover {
        background-color: #007bff;
        color: white;
      }

      .reminder-btn:focus {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }

      /* Toast styles */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .toast {
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        color: white;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        animation: toast-in 0.3s ease;
        min-width: 250px;
      }

      .toast-success {
        background-color: #28a745;
      }

      .toast-error {
        background-color: #dc3545;
      }

      .toast-warning {
        background-color: #ffc107;
        color: #212529;
      }

      .toast.fade-out {
        animation: toast-out 0.3s ease forwards;
      }

      @keyframes toast-in {
        from { 
          transform: translateX(100%); 
          opacity: 0; 
        }
        to { 
          transform: translateX(0); 
          opacity: 1; 
        }
      }

      @keyframes toast-out {
        from { 
          transform: translateX(0); 
          opacity: 1; 
        }
        to { 
          transform: translateX(100%); 
          opacity: 0; 
        }
      }
    `;

    document.head.appendChild(styleEl);
  }

  /**
   * L·∫•y event data t·ª´ current context (helper method)
   * @returns {Object|null} Event data n·∫øu c√≥
   */
  getCurrentEventData() {
    // Helper method ƒë·ªÉ l·∫•y event data t·ª´ context hi·ªán t·∫°i
    // Implementation t√πy thu·ªôc v√†o c√°ch ·ª©ng d·ª•ng qu·∫£n l√Ω state
    return null;
  }

  /**
   * Clear cache reminders
   */
  clearCache() {
    this.currentReminders.clear();
  }

  /**
   * Get all cached reminders
   * @returns {Map} Map of cached reminders
   */
  getCachedReminders() {
    return new Map(this.currentReminders);
  }
}

// T·∫°o v√† export singleton instance
export const reminderController = new ReminderController();

/**
 * Kh·ªüi t·∫°o reminder controller
 */
export function initReminderController() {
  reminderController.init();
  return reminderController;
}